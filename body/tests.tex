\chapter{Tests et évaluation}

% Explaining how your software was tested (using different datasets or in different environments), statistical evaluation of performance, results of user evaluation questionnaires, etc.
\section{Code testable} % (fold)
\label{sub:code_testable}
Avant même d'écrire des tests, il faut préparer son code à être testable. Synonyme de respecter un ensemble de principes dans le développement.\newline
Cette section présente quelques principes qui nous ont aidé à écrire du code facilement testable, mais pas seulement testable, mais plus facile à gérer et plus flexible en raison de sa meilleure modularité.\newline
Pour parvenir à écrire un code plus robuste, nous avons été amenés à suivre les cinq principes SOLID\cite{solid} introduits par Robert C. Martin.\cite{martin2002agile}
\begin{itemize}
	\itemb \textbf{Responsabilité unique} (Single responsibility principle)
	une classe, une fonction ou une méthode doit avoir une et une seule responsabilité.
	\itemb \textbf{Ouvert/fermé} (Open/closed principle)
	une entité applicative (classe, fonction, module ...) doit être ouverte à l'extension, mais fermée à la modification.
	\itemb \textbf{Substitution de Liskov} (Liskov substitution principle)
	une instance de type T doit pouvoir être remplacée par une instance de type G, tel que G sous-type de T,
	sans que cela ne modifie la cohérence du programme
	\itemb \textbf{Ségrégation des interfaces} (Interface segregation principle)
	préférer plusieurs interfaces spécifiques pour chaque client plutôt qu'une seule interface générale
	\itemb \textbf{Inversion des dépendances} (Dependency inversion principle)
	il faut dépendre des abstractions, pas des implémentations.
\end{itemize}
En plus, comme on a dit dans le chapitre précédent, nous avons adopté dans certaines parties de l'application une architecture MVVM\nomenclature{MVVM}{Modèle vue vue modèle.} au lieu de MVC\nomenclature{MVC}{Modèle vue contrôleur.} pour que nos tests couvrent une grande partie de notre code.
% subsection code_testable (end)

\section{Intérêts des tests} % (fold)
\label{sub:pourquoi_tester_}
Dans cette section nous allons répondre à la question, pourquoi écrire des tests?\newline
Les tests ont pour but de :
\begin{itemize}
	\item Montrer que notre code fonctionne :  si un changement casse quelque chose, un ou plusieurs des tests vont échouer.
	\item prévenir les bugs et les régressions : tout défaut introduit dans application à l'occasion de l'ajout de nouvelles fonctionnalités, modification de fonctionnalités existantes ou modification d'un composant externe au logiciel lui-même sera signalé par des tests qui vont échouer.
	\item penser les classes : comme on a vu dans la première section, il faut dépendre des abstractions, pas des implémentations. Donc écrire des tests incite à créer des classes dont les responsabilités sont uniques et indépendantes.
	\item offrir une documentation du code : chaque test va couvrir un cas d'usage d'une des classes. Donc si tout le code est testé, les tests sont une vraie documentation fonctionnelle du programme.
\end{itemize} 
% subsection pourquoi_tester_ (end)

\section{Outils de tests} % (fold)
\label{sub:outils_de_tests}
Afin de parvenir à dénicher les bugs et à écrire un code qui gagnera en robustesse nous avons utilisées un ensemble d'outils cités ci-dessous : 
\begin{itemize}
	\itemb \textbf{LLDB}\nomenclature{LLDB}{Low Level Debugger.} : un débogueur haute performance de nouvelle génération. Il est construit comme un ensemble de composants réutilisables qui exploitent fortement les bibliothèques existantes dans le plus grand projet LLVM, comme l'analyseur d'expression Clang et le désassembleur LLVM\nomenclature{LLVM}{Low Level Virtual Machine.}.
	\itemb \textbf{XCTest} : framework qui permet de créer et exécuter des tests unitaires, des tests de performances et des tests d'interface utilisateur pour un projet Xcode.
	\itemb \textbf{Couverture du code} (Code coverage) : indique quel pourcentage du code testé a été exécuté lors du lancement des tests unitaires correspondants. Xcode 7 a introduit une fonctionnalité de couverture du code.
	\itemb \textbf{SwiftLint} : un outil créée et maintenu par Realm pour améliorer le respect des conventions d’écritures en Swift, c'est à dire il fait une analyse statique du code.
\end{itemize}
% subsection outils_de_tests (end)

\section{Les types de test} % (fold)
\label{sub:tests}
Dans notre application nous avons eu recours à deux types de tests :
\begin{itemize}
	\item Tests manuels : conduit par les membres de l'équipe et sont destinés pour tester les interfaces utilisateurs, dans notre cas ils remplacent les tests fonctionnels.
	\item Tests unitaires : destinés à tester chaque bout de code et sont automatisés par XCTest.
\end{itemize}
% subsection tests (end)

\section{Évaluation} % (fold)
Pour évaluer les performances de notre application, nous avons utilisé Xcode Instruments qui regroupe une collection d'outils pour profiler le comportement d'exécution de l’application. Par exemple, le \textbf{Time Profiler} est un excellent outil pour mesurer les performances et analyser le temps d'exécution des différents threads ou fil d’exécution. Ou l'outil \textbf{Leaks} qui montre les fuites de mémoire qui se produisent lorsqu'un objet n'est plus référencé par quoi que ce soit mais qu'il a toujours un espace mémoire, cela signifie que la mémoire ne peut jamais être réutilisée.\clearpage
\fig{profiler.png}{Xcode Instruments}{0.6}

\paragraph{Conclusion.} % (fold)
\label{par:conclusion}
Ce quatrième chapitre avait pour finalité de montrer les approches suivies pour dénicher les bugs, et l'ensemble des principes à suivre pour écrire un code robuste.\cite{tdd}
% paragraph conclusion (end)