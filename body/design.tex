\chapter{Analyse des besoins et conception}

% Containing a comprehensive description of the design chosen, how it addresses the problem, and why it is designed the way it is.
\section{Identification des acteurs}
Dans cette section on va décrire \textbf{QUI} utilisera notre système. On commence dans un premier lieu par considérer notre système comme une boite noire pour répondre à la question qui va interagir avec notre logiciel ?\newline
les entités ou acteurs qui entre en jeu sont :
\begin{itemize}
	\item[$\bullet$] Utilisateur : Après son inscription, il peut consulter les offres de covoiturage planifiées, mais aucun autre service ne sera pour lui opérationnel tant qu'il n'a pas terminé le processus KYC (Know Your Customer), on détaille par la suite ce que le KYC dans notre cas.
	\item[$\bullet$] Chauffeur: doit pourvoir ajouter des offres de covoiturage planifiées ou instantanées.
	\item[$\bullet$] Passager: doit pouvoir faire des demandes de covoiturage instantanées et de réserver sa place dans les autres planifiées.
\end{itemize}
Il convient de noter que nos acteurs ont plus qu'un rôle qu'une personne physique, puisque une personne physique peut à la fois être un chauffeur et un passager.\newline
La figure ~\ref{fig:contextDiag} donne une représentation graphique du diagramme du contexte statique sans rentrer dans le détail des cardinalités.
\figlabel{contextDiagram.png}{diagramme de contexte statique}{0.7}{contextDiag}

\section{Spécification des besoins}
\subsection{Besoins fonctionnels} % (fold)
\label{sub:besoins_fonctionnels}
Après la définition des acteurs de notre application, on détermine les besoins de chaque acteurs pour répondre à la question \textbf{QUI} devra pouvoir faire \textbf{QUOI} ?\newline
L'expression de la liste des fonctionnalités est comme suit :
\begin{itemize}
	\item[$\bullet$] \textbf{Authentification} : chaque utilisateur doit pouvoir s'inscrire et activer son compte en vérifiant son numéro du téléphone et son émail.
	\item[$\bullet$] \textbf{Consultation des offres} : chaque utilisateur doit pouvoir après activation du compte consulter la liste des offres planifiés.
	\item[$\bullet$] \textbf{Terminer le KYC} : l'utilisateur doit pouvoir prouver son identité afin que l’ensemble des services seront accessibles (Identification doit être automatisée).
\end{itemize}
Tout service de ceux qui suivent n'est exploitable que si l'utilisateur à terminer le processus KYC.
\begin{itemize}
	\item[$\bullet$] \textbf{Ajout des offres} : un chauffeur peut publier des offres de covoiturages planifiées.
	\item[$\bullet$] \textbf{lancement du trajet} : un conducteur peut lancer un covoiturage instantané, l’itinéraire optimal doit s’afficher tout au long de la course. il reçoit aussi des notifications de prise en charge des passagers.
	\item[$\bullet$] \textbf{Demande de covoiturage} : un passager peut demander un covoiturage instantané (la saisie de la demande par le système doit être en temps réel), ou consulter la liste des covoiturages planifiés afin de réserver sa place.
	\item[$\bullet$] \textbf{Réseau des utilisateurs} : Les utilisateurs peuvent avoir un réseau ainsi que, synchroniser les leurs dans les réseaux sociaux.
	\item[$\bullet$] \textbf{Le matching} : l'affectation des conducteurs aux passagers offre un modèle riche qui tient compte non seulement de l'adéquation des itinéraires, mais aussi de l'âge, du sexe et le nombre de valises.
	\item[$\bullet$] \textbf{Historique des trajets} : tout utilisateur doit avoir la liste de ses trajets planifiés ou qui ont été faits.
	\item[$\bullet$] \textbf{Annulation} : tout utilisateur doit pouvoir annuler des voyages.
	\item[$\bullet$] \textbf{Paiement} : Un passager doit pouvoir payer soit par cash ou par carte bancaire.
\end{itemize}
Cette liste n'est pas exhaustive, et certaines fonctionnalités ont été éliminées pour des raisons de clarté.
% subsection besoins_fonctionnels (end)

\subsection{Besoins non fonctionnels} % (fold)
\label{sub:besoins_non_fonctionnels}
Outre les besoins fonctionnels, un système d'informations doit répondre à un ensemble d'exigences non fonctionnelles.
\begin{itemize}
	\itemb \textbf{Performance} : le chargement de l’application, ouverture d’écran, des délais de rafraîchissement et le temps de réponse de l'algorithme de matching.
	\itemb \textbf{Disponibilité} : l'application doit être opérationnelle à n'importe quel moment.
	\itemb \textbf{Architecture} : le respect du modèle du développement logiciel MVC imposer par Apple.
	\itemb \textbf{Tests} : les tests unitaires doivent être écrits et couvrir 90\% du code.
	\itemb \textbf{Ergonomie} : la densité d’éléments sur les écrans, la disposition et le flux, les couleurs.
	\itemb \textbf{Interface graphique} : les interfaces graphiques doivent être responsive c'est à dire, elles s'adaptent aux différentes tailles d’écran des appareils iOS. (Dans notre cas on va développer notre application que pour le mode portrait)
	\itemb \textbf{Sécurité} : les différents échanges entre les composants de l'application doivent être chiffrés. l’accès a l'API se limite a nos application clientes. protéger les données de l'utilisateur comme la photo de sa CIN.
\end{itemize}
En plus de ces besoins l'application a des défis à surmonter vu que nous développons dans un environnement mobile : 
\begin{itemize}
	\item les petites tailles d’écran.
	\item la vie de la batterie.
	\item performances du matériel.
\end{itemize}
% subsection besoins_non_fonctionnels (end)

\section{Analyse des besoins}
Nous avons identifié les acteurs et un certain nombre de fonctionnalités. Maintenant il est temps de définir en détail chaque fonction et l'attribuer à un acteur.
Nous allons tracer le diagramme de cas d'utilisation et quelques diagrammes de séquence système.
\subsection{Diagramme de cas d'utilisation} % (fold)
\label{sub:diagrammes_de_cas_d_utilisation}
Un cas d’utilisation (use case) représente un lot d’actions qui sont réalisées par le système et qui met donc en évidence de quelle façon les acteurs utiliseront le logiciel.

\fig{usecasediagram.png}{diagramme de cas d'utilisation}{0.45}
% subsection diagrammes_de_cas_d_utilisation (end)

\subsection{Diagrammes de séquences} % (fold)
\label{sub:diagrammes_de_séquence}
% subsection diagrammes_de_séquence (end)
Validation des cas d'utilisation,
pour comprendre la logique de
l'application
\\Complète le diagramme des cas
d’utilisation en mettant en
évidence les objets et leurs
interactions d’un point de vue
temporel
\\Outils de documentation, peu
rigoureux, pas tout le temps
nécessaires
\\Pas de flots de contrôle dans un
diagramme de séquence, en faire
plutôt un autre 
\subsection{Diagramme de classe} % (fold)
\label{sub:diagramme_de_classe}

% subsection diagramme_de_classe (end)
\section{Conception} % (fold)
\label{sec:conception}

\subsection{processus du matching} % (fold)
\label{sub:algorithme}
Après la description formelle de nos besoins, on va décrire comment se déroule le processus de matching ou de jumelage qui est le cœur de notre métier.\newline
Pour des raisons de confidentialité, on ne va pas rentrer dans les détails et on va se limiter aux cas simples.\newline
Au début du processus, un conducteur qui veut partager sa voiture avec des passagers potentiels enregistre 
une offre qu'on va noter $O = (O_D, O_A)$, où $O_D$ est le point (position géographique) de départ, et $O_A$
le point d'arrivée. En plus le conducteur nous renseigne sa position en temps réel $O_t$, qu'elle met à jour chaque fois qu'il s'est déplacé d'une distance $d$. Le système procède au découpage du trajet O en point distancé de $d$ ce qui nous donne que $O = (O_{1}, O_{2},\ldots , O_{n})$.\newline
Un passager qui demande un covoiturage enregistre sa demande qu'on note $D = (D_D, D_A)$, où $D_D$ est le point (position géographique) de départ, et $D_A$ le point d'arrivée.\newline
Dans un premier temps on va considérer le scenario où on a une seule offre et une seule demande. Notons $C_D$ et $C_A$ l'ensemble des points des deux cercles ayant pour centre respectivement $D_D$ et $D_A$ et pour rayon $r$.
Pour qu'un covoiturage ait lieu il faut : 
\begin{equation}
O_R \subset C_D 
\label{eqution1}
\end{equation}
ce qui veut dire que la position actuelle du chauffeur est d'une distance moins de $r$.
Deuxièmement, on va vérifier que le point d'arrivée du passager est sur le chemin du conducteur. Ce qui peut se traduire en :
\begin{equation}
(O_{1}, O_{2},\ldots , O_{n}) \cap C_D \ne \emptyset
\label{eqution2}
\end{equation}
Dans le cas de plusieurs offres l'algorithme choisit le chauffeur on calculant un score qui se détermine par la convenance des préférences du chauffeur et le passager. Et par le temps de détour pour les deux offres, par détour on apprend le temps qui va mettre le chauffeur pour prendre en charge le passager.
\fig{asset.png}{processus de matching dans le cas d'une seule offre}{0.5}
% subsection algorithme (end)
% section conception (end)