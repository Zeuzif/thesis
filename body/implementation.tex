\chapter{Implémentation}

% Containing a comprehensive description of the implementation of your software, including the language(s) and platform chosen, problems encountered, any changes made to the design as a result of the implementation, etc.
\section{Architecture} % (fold)
\label{sec:architecture}
\subsubsection{Architecture globale} % (fold)
\label{ssub:architecture_globale}
L’architecture globale de mise en œuvre est illustrée par la figure \Figref{architecture.png}. Cette architecture est subdivisée en 3 couches et repose sur l’utilisation des services Web, qui ont pour objectif d’assurer une flexibilité d’échange de services entre les différents composants du système.\newline
Les différentes parties vont être décrits comme suit :
\begin{enumerate}
	\item Couche présentation : c'est notre application cliente dans notre cas mobile, qui tourne sur le système IOS ou Android et assure l'affichage et le dialogue avec l'utilisateur.
	\item Coté serveur : assure le traitement métier des données et correspond à la mise en œuvre de l'ensemble des règles de gestion et de la logique applicative, cette partie contient deux principaux services Web : l'un gère les covoiturages instantané et l'autre planifié. Elle est hébergée sur le cloud Digital Ocean :
	\begin{itemize}
		\item Service de covoiturage instantané : il assure les demandes et offres de covoiturage temps réel en utilisant l'algorithme de matching. chaque fois qu'un passager lance une offre il est intercepté par ce service qui lance le processus du matching. 
		\item Service de covoiturage planifié : il est responsable des demandes et offres de covoiturage planifié ou statique. il est sollicité chaque fois une offre ajouté ou à chaque demande de prise en charge d'un passager par un conducteur.
	\end{itemize}
	Nos API ou services sont conformes au standard REST (representational state transfer), donc la communication entre ses services est basée sur le protocole Http. Outre ils respectent des contraintes architecturales comme : La communication client–serveur s'effectue sans conservation de l'état de la session de communication sur le serveur entre deux requêtes successives.\cite{fielding2000architectural}
	\item Base de données : Elle correspond à la partie gérant l'accès aux données de l'application, deux bases de données sont utilisées :
	\begin{itemize}
		\item MySql : les informations sur les utilisateurs, les offres planifiés où autres donnés qui ne changent pas souvent, résident sur cette base.
		\item Firebase : les données comme les offres instantanée et les positions des conducteurs sont sollicités en lecture en temps réel, donc ils seront hébergés sur cette base.
	\end{itemize}
\end{enumerate}
\fig{architecture.png}{architecture de l'application}{0.5}
% subsubsection architecture_globale (end)
\subsubsection{Architecture client side}
\subsubsection{MVC} % (fold)
 \label{ssub:mvc}
 Commençons par définir ce que c'est que MVC. Le Model View Controller permet de diviser son programme en trois parties indépendantes :
 \begin{itemize}
 	\item Le modèle : il contient la logique de l'application, il renferme nos entités qui sont des classes ou structures qui interagissent entre eux, et aussi les servies qui peuvent par exemple faire des appels réseau ou accéder à une base de données.
 	\item Le contrôleur : il récupère  et formate les informations du modèle pour les passer à la vue.
 	\item La vue : c'est ce que l'utilisateur voit, c'est l'interface de l'application.
 \end{itemize}
 Apple a choisi par défaut le très populaire patron de conception architectural MVC pour les applications iPhone. Cela veut dire que la façon dont ils ont conçu le développement d'application iPhone nous encourage à respecter ce design. \newline
 MVC avant tout, est un ensemble de règles de communication :
 \begin{itemize}
 	\item La vue et le modèle ne peuvent \textbf{JAMAIS} communiquer. chacun d'eux ignore l’existence de l'autre.
 	\item Le modèle peut parler indirectement au contrôleur par des notifications ou des fermetures (closures). C'est une communication aveugle, c'est à dire le modèle ne contient pas de référence du contrôleur.
 	\item La vue parle au contrôleur en lui délégant la gestion des interactions de l'utilisateur avec l'application, le contrôleur dans ce cas s'engage à répondre à sa demande comme montre la figure 
 	\fig{target_action.jpg}{le patron de conception target-action}{0.4}\newline
 \end{itemize}
 La figure\Figref{mvc.png} résume ce qui a été dit dans cette partie.
 \fig{mvc.png}{patron de conception mvc}{0.2}
 % subsubsection mvc (end) 

 \subsubsection{Difficultés rencontrées et pourquoi MVVM ?} % (fold)
 \label{ssub:difficultés_rencontrées_et_pourquoi_mvvm_}
 Au fur et à mesure que notre application croît en taille et en portée, les problèmes complexes de maintenance commencent à surgir. Nous avons rencontré beaucoup de difficultés à tester nos contrôleurs et ce, même en essayant de les alléger et de déléguer beaucoup de fonctionnalités à des classes de services ou modèle. C'est ce qui nous a poussé à adopter une nouvelle structuration du code : le modèle MVVM.\cite{mvvm}\newline
 MVVM vise à exporter les traitements de la logique de présentation dans des entités à part entière qui s'appellent les ViewModels, et qui seront placées entre la Vue/Contrôleur (qui désormais constitue une seule entité) et le modèle comme montre la figure\Figref{mvvm.png}.
 \begin{itemize}
 	\item Le modèle : reste le même que celui de MVC.{}
 	\item La vue/contrôleur : cette couche représente le contexte de l'interface utilisateur et ses interactions. Désormais, nous considérons les vues et leurs contrôleurs MVC comme une seule entité.
 	\item Le View Model : le rôle qui incombe au ViewModel est de récupérer les données à partir du modèle et de les rendre disponibles à la vue sous une meilleure forme. De cette manière, on aura des contrôleurs beaucoup moins chargées qu'avant. On aurait allégé les tests UI puisqu'on a transformé une grande partie des contrôleurs en un modèle de données testable unitairement. 
 \end{itemize}\
 \fig{mvvm.png}{le patron de conception MVVM}{0.2}
 % subsubsection difficultés_rencontrées_et_pourquoi_mvvm_ (end)
% section architecture (end)

\section{Technologies et outils utilisés} % (fold)
\label{sec:technologies_et_outils_utilisés}

% section technologies_et_outils_utilisés (end)

\section{Justification des choix techniques} % (fold)
\label{sec:justification_du_choix_technique}

% section justification_du_choix_technique (end)

